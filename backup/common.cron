#!/usr/bin/env bash
# Common utilities for .cron backup scripts.

_display_seconds="$(realpath "$(dirname "${BASH_SOURCE}")/../display-seconds")"

# Implements a periodic backup with a maximum number of backups by
#   1) Checking to see if the most recently modified file in a directory was
#      modified after the backup interval
#   2) Invoking a passed in backup command
#   3) Keeping only the n most recently modified files
#
# $1: Backup directory to check modified times, number of backups in
# $2: Backup interval in seconds
# $3: The number of backups we should retain
# $4+: The backup command
backup::cron::periodic_with_maximum_backups() {
    local backup_dir="${1:?}"
    local backup_interval="${2:?}"
    local num_backups="${3:?}"
    local cmd=( "${@:4}" )

    if [[ "${backup_interval}" -ne 0 ]]; then
        local seconds_since_last_backup=$(\
            backup::cron::seconds_since_last_file_modified "${backup_dir}")
        if [[ -n "${seconds_since_last_backup}" \
            && "${seconds_since_last_backup}" -lt "${backup_interval}" ]]; then
            local remaining=$((backup_interval-seconds_since_last_backup))
            echo "Will backup again in $("${_display_seconds}" ${remaining})" 1>&2
            return 0
        fi
    fi

    "${cmd[@]}"
    if [[ $? != 0 ]]; then
        echo "backup command failed" 1>&2
        return 1
    fi

    backup::cron::keep_n_most_recent_files "${num_backups}" "${backup_dir}"
    if [[ $? != 0 ]]; then
        echo "Could not prune old backups." 1>&2
        return 1
    fi
}

# rsync's an external program's backup directory with another folder, with some
# expectations about how often the external program should be backing itself up.
#
# $1: Backup directory
# $2: Expected backup interval in seconds. This should probably have some wiggle
#     room included.
# $3: External program's backup directory
# $4: Any extra rsync args.
backup::cron::copy_external_backup_folder() {
    local backup_dir="${1:?}"
    local backup_interval="${2:?}"
    local external_dir="${3:?}"
    local extra_args=( "${@:4}" )

    rsync --archive --delete "${extra_args[@]}" \
        "${external_dir}" "${backup_dir}"
    if [[ $? != 0 ]]; then
        return 1
    fi

    local seconds_since_last_backup="$(\
        backup::cron::seconds_since_last_file_modified "${backup_dir}")"
    if [[ $? != 0 ]]; then
        echo "There are no backup files in ${external_dir}." 1>&2
        return 1
    fi

    echo "Last backed up $("${_display_seconds}" "${seconds_since_last_backup}") ago." 1>&2
    if [[ "${seconds_since_last_backup}" -gt "${backup_interval}" ]]; then
        echo "Expected at most $("${_display_seconds}" "${backup_interval}")." 1>&2
        return 1
    fi
}

# Prints the number of seconds since the most recently modified file in $1 was
# modified.
#
# $1: A directory containing files.
# @returns 1 if $1 is an empty directory.
backup::cron::seconds_since_last_file_modified() {
    local most_recent="$(ls -1td "$1"/* 2>/dev/null | head -1)"
    if [[ -z "${most_recent}" ]]; then
        return 1
    fi

    local now="$(date +%s)"
    local mtime="$(stat -c "%Y" "${most_recent}")"
    echo $((now-mtime))
}

# Deletes all but the n most recently modified files from $2.
#
# $1: n
# $2: A directory
backup::cron::keep_n_most_recent_files() {
    local n="$1"
    local dir="$2"

    local num_backups=$(ls -1 "$dir" | wc -l)
    local num_extra_backups=$((num_backups - n))
    if [[ $num_extra_backups -gt 0 ]]; then
        local IFS=$'\n'
        local to_remove=( $(ls -1td "$dir"/* | tail -"${num_extra_backups}") )
        unset IFS
        echo "Removing ${num_extra_backups} extra backups: ${to_remove[@]}" 1>&2
        rm "${to_remove[@]}"
    fi
}
